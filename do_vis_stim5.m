function [behav, trial_num] = do_vis_stim(wp, start_block_time, target_length, ndots, center, ...xmin, xmax, ymin, ymax, vis_stim_passive, stim_per_block, targ_min, ...targ_max, colors, pfs, stim_length, fix_dimmed, do_fix, between_fix_dur, next_fix, fix_rand_coef, frame_rate, fix_cord, ...fix_stim, WHITE_INDEX, GRAY_INDEX, epoch_order, run, epoch_num, showme, ...trial_num, behav, response_time, Bkcolor, resp, motion_coh)%newest version: 7/12/07. calls draw dots, NOT fillrect% This gets called from the main SS_BASELINE.M if% epoch_order(run, epoch_num) == vis_stim or% vis_stim_passive%% Pregenerate our STIM_PER_BLOCK stimuli (see STIM), then% loop over them, displaying each one for 0.4s. Each% stimulus has an associated color and motion direction.%% TARGET_LENGTH = 8.8s, i.e. the duration of a visual% stimulation block.%% STIM_PER_BLOCK = 22, i.e. the number of stimuli to show% within the 8.8s TARGET_LENGTH%% STIM = STIM_PER_BLOCK x 2 (color, motion). MOTION: 1 = up,% 2 = right, 3 = down, 4 = left%% SHOWME = a debugging variable. If True, the experiment% will be displayed as usual with the Psych Toolbox% functions. If False, all of those will be skipped over, to% make it easier to put in keyboards and play around in the% workspace.%% TRIAL_NUM = the row of the behavioral matrix that we're % logging into. Gets updated every time a new fixation % cross is show, or every time a new set of dots is shown % (depending on which one of the two tasks we're logging at the time).%% This is the only place in the experiment where the moving dots get % orchestrated. do_vis_stim5.m deals with two kinds % of blocks: %% - vis_stim_passive (where the dots are displayed, but the %   subjects are performing the fixation task)% - vis_stim (where the dots are displayed, and the subjects %   are comparing their motion with the target)%% In both cases, the fixation cross is blinking and the dots are moving. The % only difference is which task the subject is performing, and which behavioral % data we are logging.%% structure:%%   first, initialize stuff like the stim and target_motion%%   while < target_length%     %     if time for a stimuli change%%       periph_counter+1, come up with new x and y, choose new colors etc.%%     move the dots%%     redraw the dots%resp=50; %for space bar%resp=22; %first button in scanner.% Each row of DOTS contains the details for a single dot.%% Columns = x, y, color, motion%% Even-numbered dots are colored. Odd-numbered dots are% black.dots = zeros(2*ndots,4);% [x, y, color, size] for each dot to be drawndots(:, 4)=3;%dot sizedots(1:2:ndots*2-1, 3)=Bkcolor;% this is going to be our counter, ranging from 1 to% STIM_PER_BLOCK (it get incremented as soon as the loop% over stimuli begins below)periph_counter = 0;targ_motion = 0;% periph_counter = 1;check_resp=0; % 0 = not checking responses, 1 = checking responses%disp 'visual_block'% for the length of the target period (8.8 sec)% store the starting time to make debugging easierinit_time = GetSecs;% randomly choose all colors and dirs so no 2 same in a% row, no matter what the condition is% set colortemp=randperm(4); % randomly rearrange the gumbers 1-4stim(1,1)=temp(1); % picking out colorfor i=2:stim_per_block	temp=randperm(4);	while stim(i-1,1) == temp(1) % while the first color is still being shown		temp=randperm(4); %randomly rearrange the numbers again	end	stim(i,1)=temp(1);end%set motiontemp=randperm(4);stim(1,2)=temp(1); % picking out motion directionfor i=2:stim_per_block	temp=randperm(4);	while stim(i-1,2) == temp(1) % while the first motion direction is still being shown		temp=randperm(4);	end	stim(i,2)=temp(1);end% we moved a big chunk of code relating to hilda's color% condition into discarded_color_code_070706.m, because% stephanie said we wouldn't need it% if you are supposed to attend to periphery, i.e.if epoch_order(run, epoch_num) ~= vis_stim_passive		%this checks to make sure do_fix = 0 (i.e., we are doing the peripheral task)	if do_fix == 1		error ('we should not be doing fixation task now')	end		% this part of the code sets the targets. don't need to	% set targets if this is a passive block	temp=randperm(4);	while temp(1)==targ_motion %make sure don't choose same targ motion twice in a row		temp=randperm(4);	end	targ_motion=temp(1);%set targ motion for this run		stim(1, 2)=temp(1);	for i=2:stim_per_block		%choose random number from 1-3 for nontarg motions		temp=randperm(3);		while stim(i-1, 2)==temp(1)			temp=randperm(3);		end		stim(i,2)=temp(1);	end	%make three motions not targ motion	indices=stim(:,2)== targ_motion;% create list of numbers that do not contain target direction	if length(indices)>0 %if targ_motion not 4 (since only motion not in stim) set ones that targ to 4		stim(indices, 2)=4;	end	%add back in first targ stim	stim(1,2)=targ_motion;	%now need to set targ stimulus	next_targ=1+(targ_min-1) + ceil((targ_max-targ_min+1).*rand(1,1));% will give us a number between 4 and 7	for i=1:stim_per_block		if i==next_targ			stim(i,2)=targ_motion;						next_targ=i+1+(targ_min-1) + ceil((targ_max-targ_min+1).*rand(1,1));		end	end%end of setting up stimulus array		%add to behavioral matrix	%stimcounter used to be called periph_counter, which i think used to be calle nstim, 	% but we changed it to avoid confusion with the periph_counter below.% 	for stimcounter=1:stim_per_block% 	%if a target stimulus,% 	 	if stim(stimcounter,2)==targ_motion & do_fix ==0 %this code collects behavioral responses from the peripheral task% 	        % xxx - should this be stim(periph_counter,2)??? originally it was set to (periph_counter,1)% 	 		trial_num=trial_num+1; %increment targ% 	 		behav=[behav; trial_num 0 0 epoch_order(run, epoch_num), run];% add to the behav matrix%  			check_resp=1;%start checking for resp% 	 		start_resp_time=GetSecs;%start resp time% 	 	end% 	 end	end %end of if statement (if ~= visual_passive)while GetSecs < start_block_time + target_length%block length		%%%%%%%%%%%%%%%%%%%%%%%%%%%    % fixation stimuli	%		% if not dimmed and time for next fixation dimming, then	% dim the fixation cross	if ~fix_dimmed & GetSecs > start_block_time + next_fix 		if showme			SCREEN(wp,'DrawText','+', fix_cord(1),fix_cord(2), GRAY_INDEX);		end		fix_dimmed=1;		fix_start=GetSecs;		% only bother with setting up the behavioral logging if we're doing the fixation task		if do_fix %hilda's experiment only records the block number and run for the fixation task, not the peripheral task			trial_num=trial_num+1;%move to the next row of the behavioral matrix			behav=[behav; trial_num, 0, 0, epoch_order(run, epoch_num), run];%first zero for if got resp, next one rt			check_resp=1;%set flag for getting responses			start_resp_time=GetSecs;		end	end	%	%undim fixation cross	if fix_dimmed & GetSecs > fix_start+fix_stim % if fix dimmed and length of fix dim has passed (.40) then undim		if showme			SCREEN(wp,'DrawText','+', fix_cord(1),fix_cord(2), WHITE_INDEX);		end		fix_dimmed=0;		next_fix = next_fix + fix_stim + between_fix_dur + rand*fix_rand_coef;% Varies fixation dimming between some minimum amount of time		% (between fix dur) and some maxiumum amount of time (fix_rand_coef). In this case, it varies between 2 and 4 seconds						end		%%%%%%%%%%%%%%%%%%%%%%%%%	% peripheral dots stimuli	%	% GetSecs > start_block_time + periph_counter*stim_length: this	% checks whether enough time has passed (based on the	% number of stimuli so far) for us to move on to th enext	% one	%	% (periph_counter<stim_per_block): this checks that we don't go	% over the number of stimuli	if (GetSecs > start_block_time + periph_counter*stim_length) & (periph_counter < stim_per_block) 		periph_counter=periph_counter+1;		% set up the behavioral logging for peripheral dots task, after the first trial (the demo target)		if do_fix==0 & stim(periph_counter,2)==targ_motion & periph_counter > 1%this code collects behavioral responses from the peripheral task.			% we want periph counter to be larger than 1, so that the program does not check responses for the first target in the block.	 		trial_num=trial_num+1; %move to the next row of the behavioral matrix	 		behav=[behav; trial_num 0 0 epoch_order(run, epoch_num), run];% add to the behav matrix 			check_resp=1;%start checking for resp	 		start_resp_time=GetSecs;%start resp time	 	end			if check_resp %if collecting responses			[keyIsDown, secs, keycode] = kbcheck; %check response			if find(keycode(resp)) %resp not trigger				behav(trial_num, 2)=1;%1 for hit response				behav(trial_num, 3)=GetSecs -start_resp_time;%enter resp time. %%% where is start_resp_time first set?				check_resp=0; %stop checking			elseif GetSecs - start_resp_time > response_time %if time for subject to respond has passed, stop checking				check_resp=0;			end		end				firsttime_newcolor=1;		tempdots=dots(2:2:ndots*2, 1:2); 		% make array of stimuli for this block		%		% dot positions in Cartesian pixel coordinates relative to center		x = (rand(ndots,1) * (xmax-xmin) + xmin);		y = (rand(ndots,1) * (ymax-ymin) + ymin);				% store the x and y coordinates for the colored dots		dots(2:2:ndots*2, 1:2)=[x,y];		% store the color for the colored dots		dots(2:2:ndots*2, 3)=colors(stim(periph_counter,1));				%set direction		temp_coh = motion_coh;		temp=2*pi*rand(ndots, 1);		dx=pfs*cos(temp);		dy=pfs*sin(temp);		coh_dots=rand(ndots,1) < temp_coh;%find for which indices the following is true: 										  %where the number is less than the motion coherence		coh_dots=find(coh_dots); % find the indices of all the dots that are 								 %less than the motion_coherence		Lcoh_dots=length(coh_dots);%length of those index values		switch(stim(periph_counter,2))		case 1			%upward motion			dx(coh_dots) = zeros(Lcoh_dots,1);		% change in x (in pixels) per frame			dy(coh_dots) = pfs * (-1*(ones(Lcoh_dots,1)));	% change in y (in pixels) per frame		case 2			%rightward motion			dx(coh_dots) = pfs * ones(Lcoh_dots,1);	% change in x (in pixels) per frame			dy(coh_dots) = zeros(Lcoh_dots,1);		% change in y (in pixels) per frame		case 3			%downward motion			dx(coh_dots) = zeros(Lcoh_dots,1);		% change in x (in pixels) per frame			dy(coh_dots) = pfs * ones(Lcoh_dots,1);	% change in y (in pixels) per frame		case 4			%leftward motion			dx(coh_dots) = pfs * (-1*(ones(Lcoh_dots,1)));	% change in x (in pixels) per frame			dy(coh_dots) = zeros(Lcoh_dots,1);		% change in y (in pixels) per frame		otherwise			error('Unknown motion type')		end % finished rejigging for new motion parameter		end % finished rejigging things for the new stimulus	% check for responses. since we're using the same variables 	% for behavioral logging for both tasks, the kbcheck blocks can do 	% double duty. we're being careful above when we set up the 	% new behav matrix row to only increment trial_num etc. for 	% the task being logged	%	% these are the places where we run kbcheck	% - just before DrawDots	% - during DrawDots frame refresh	% - right after DrawDots is shut off	%	% behav = [trial num, resp, rt, block type, run number]	% checks before DrawDots	%_______________________________________________________________	if check_resp %if collecting responses		[keyIsDown, secs, keycode] = kbcheck; %check response		if find(keycode(resp)) %resp not trigger			behav(trial_num, 2)=1;%1 for hit response			behav(trial_num, 3)=GetSecs -start_resp_time;%enter resp time. %%% where is start_resp_time first set?			check_resp=0; %stop checking		elseif GetSecs - start_resp_time > response_time %if time for subject to respond has passed, stop checking			check_resp=0;		end	end	%_______________________________________________________		% end % of the stimuli-change if block		%move dots___________________________	x = x + dx;	y = y + dy;	% check to see which dots have gone beyond the borders of the annuli	x_out = find(x > xmax);				% dots past outer border of central annulus	x_in = find(x < xmin);				% dots past inner border of central annulus	y_out = find(y > ymax);				% dots past outer border of central annulus	y_in = find(y < ymin);				% dots past inner border of central annulus		L = [x_out; x_in; y_out; y_in];					% locus of all dots that have gone beyond borders	nL = length(L);		if nL		% first cycle radius back to the beginning				x(x_out) = xmin;	% cycle dots at right border to the left		x(x_in) = xmax;		% cycle dots at left border to the right		y(y_out) = ymin;	% cycle dots at top border to the bottom		y(y_in) = ymax;		% cycle dots at bottom border to the top	end	% get the black coordinates from the colored coordinates		if firsttime_newcolor		dots(1:2:ndots*2-1, 1:2)=tempdots;		firsttime_newcolor=0;	else		dots(1:2:ndots*2-1, 1:2)=dots(2:2:ndots*2, 1:2);	end		% rather than trying to draw black dots exactly on top of	% the colored ones, which was difficult to get right, we	% just decided to mask the whole area with a black	% rectangle	%	% for some reason, we had to make the rectangle a little	% bigger than expected, otherwise the edges don't get	% cleared	% 	if showme, Screen(wp,'FillRect',0,[xmin+center(1) ymin+center(2) xmax+center(1)+3 ymax+center(2)+3]);	% 	end		% get the new (shifted) colored coordinates	dots(2:2:2*ndots,1:2) = [x y];		% draw the coloreds	if showme		DrawDots(wp, dots, center);	end	%check for responses regardless of what task it is	%checks after DrawDots	%_______________________________________________________________	if check_resp %if collecting responses	    [keyIsDown, secs, keycode] = kbcheck; %check response	    if find(keycode(resp)) %resp not trigger			behav(trial_num, 2)=1;%1 for hit response			behav(trial_num,3)=GetSecs -start_resp_time;%enter resp time			check_resp=0; %stop checking		elseif GetSecs - start_resp_time > response_time %if time for subject to respond has passed, stop checking			check_resp=0;		end	end	%_______________________________________________________		ttime=GetSecs;	% while time < waitblanking, 1 framesb.  	% makes sure that the frames are not happing too fast. Also checking a bunch of times per frame.	%checks during DrawDots	% check for responses regardless of what task it is	while GetSecs <ttime + (1/frame_rate) 	    if check_resp %if collecting responses			[keyIsDown, secs, keycode] = kbcheck; %check response			if find(keycode(resp)) %resp not trigger				behav(trial_num, 2)=1;%1 for hit response				behav(trial_num,3)=GetSecs -start_resp_time;%enter resp time				check_resp=0; %stop checking			elseif GetSecs - start_resp_time > response_time %if time for subject to respond has passed, stop checking				check_resp=0;			end		end	end% end of while loop 14 lines above	end %end of while loop that drives the visual stimulus block (for 8.8. sec)% if showme, Screen(wp,'FillRect',0,[xmin+center(1) ymin+center(2) xmax+center(1)+3 ymax+center(2)+3]);% enddots(1:2:2*ndots-1, 1:2)=dots(2:2:2*ndots, 1:2);% match x and y coordinates of colored dots to black dotsif showme	DrawDots(wp, dots(1:2:2*ndots-1, :), center);	%draw black coordinatesendif showme	SCREEN(wp,'DrawText','+', fix_cord(1),fix_cord(2), WHITE_INDEX);end